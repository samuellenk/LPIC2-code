---
title: "Praxis-Beispiele: PAM-Authentisierung ![](images/LPIC2_logo.png){width=20 height=20}"
subtitle: "LPIC 2"
author: "![SL](images/SL_foto_300.png){width=20 height=20} [&copy; Samuel Lenk](https://linux-trainings.de/)"
theme: "Luebeck"
colortheme: "whale"
aspectratio: 169
colorlinks: true
urlcolor: gray
linkcolor: gray
---

# Übersicht

Beispiele in diesem Abschnitt:

1. PAM und 2FA mit `libpam-google-authenticator`
2. Bruteforce-Angriffe auf Passwörter verhindern mit `pam_faillock`
3. Nutzung von `pam_mkhomedir.so`

# Voraussetzungen

- für diese Beispiele benötigst du ein funktionales Linux-System (Distribution Debian/Redhat/...)
- GUI ist nicht nötig

# PAM und 2FA mit `libpam-google-authenticator`

- funktioniert für viele Distributionen und 2FA/OTP-Tools
- hier wird **beispielhaft** das Setup **mit Debian und Google Authenticator** gezeigt
- Setup geht davon aus, dass man Passwort-Authentifizierung für SSH verwendet und zusätzlich TOTP als zweiten Faktor einsetzt
- Smartphone mit 2FA-App wird benötigt
  - es muss nicht Google Authenticator sein
  - hier wurde [Secur](https://f-droid.org/en/packages/com.u2fa.secur/) von [FDroid](https://f-droid.org/en/) verwendet

## Umsetzung

1. Paket-Listen auffrischen: `sudo apt update`
2. PAM-Modul installieren: `sudo apt install libpam-google-authenticator`
3. als User ausführen: `google-authenticator`
  - Abfragen beantworten
  - erstellt Datei `~/.google_authenticator`
4. PAM-Modul anpassen: `sudo nano /etc/pam.d/sshd`
  - auskommentieren: `# @include common-auth`
  - neu darunter einfügen: `auth required pam_google_authenticator.so`
5. SSH-Konfiguration anpassen: `sudo nano /etc/ssh/sshd_config`
  ```bash
  KbdResponseAuthentication yes
  AuthenticationMethods publickey,keyboard-interactive
  UsePAM yes
  ```
  - eventuell weitere Methoden hinzufügen (wie Passwort)
6. SSH-Dienst neu starten: `sudo systemctl restart sshd.service`
7. Test: `ssh -i ~/.ssh/dein_key_hier tux@debian`
  - andere Session vorher **nicht** trennen

# Bruteforce-Angriffe auf Passwörter verhindern mit `pam_faillock`
  
## Konfiguration für Redhat

- man kann ```pam_faillock``` über Konfigurations-Dateien editieren
- aber Redhat bietet einen einfachen Weg mit ```authselect```

Profile anzeigen:
```bash
sudo authselect list
```

Details zum ```minimal```-Profil anzeigen:
```bash
sudo authselect list-features minimal
```
- zeigt auch ```with-faillock``` als Funktion

Profil einschalten:
```bash
sudo authselect select minimal --force
```

Funktion aktivieren:
```bash
sudo authselect enable-feature with-faillock
```

Konfiguration ```/etc/security/faillock.conf``` anpassen:
```bash
silent
deny = 3
unlock_time = 600
even_deny_root
```

## Konfiguration für Debian

- auf Debian ist das ```authselect```-Modul nicht verfügbar
- also muss Konfiguration angepasst werden

in ```/etc/pam.d/common-auth``` **oben** diese Zeilen einfügen:
```bash
auth    required    pam_faillock.so preauth silent
auth    required    pam_faillock.so authfail
```

in ```/etc/pam.d/common-account``` **unten** diese Zeilen einfügen:
```bash
auth    required    pam_faillock.so
```

Konfiguration ```/etc/security/faillock.conf``` anpassen:
```bash
silent
deny = 3
unlock_time = 600
even_deny_root
```

## Fehlerhafte Login-Versuche simulieren

User anlegen:
```bash
sudo adduser dummy
```

Logins probieren:
```bash
ssh dummy@<HOSTNAME>
```

## User prüfen, entsperren und Logs betrachten

nach fehlgeschlagenen Login-Versuchen diese anzeigen:
```bash
sudo faillock
```

Beispiel-Ausgabe für den gesperrten User:
```bash
dummy:
When                Type  Source                                           Valid
2026-01-28 11:28:16 RHOST 192.168.122.1                                        V
2026-01-28 11:28:40 RHOST 192.168.122.1                                        V
2026-01-28 11:28:44 RHOST 192.168.122.1                                        V
```

User vor Ablauf der Sperrzeit freigeben:
```bash
sudo faillock --reset --user [BENUTZER]
```
- danach funktioniert die Anmeldung wieder

# Nutzung von `pam_mkhomedir.so`

- bei Erstellung vieler User sollen nicht gleich alle Home-Verzeichnisse erstellt werden
- sondern erst bei Anmeldung eines konkreten Users

## Umsetzung

User erstellen **ohne** Home-Verzeichnis:
```bash
useradd -M maxi
```

kein Home-Verzeichnis wurde erstellt:
```bash
ls /home
sudo su - maxi # geht auch ohne Passwort vom User
```

Konfiguration für PAM anpassen:
```bash
nano /etc/pam.d/su-l
```

Eintrag **anhängen** an `/etc/pam.d/su-l`:
```bash
session   optional    pam_mkhomedir.so  umask=077
```
- Verzeichnis wird `optional` erstellt
- und gleichzeitig privat gemacht (`umask`)
- mehr Informationen zum Modul unter `man pam_mkhomedir.so`

## Test

Anmeldung mit dem User:
```bash
sudo su - maxi
```

Prüfung, ob Home-Verzeichnis existiert:
```bash
pwd
```
